#ifndef LIFETIME_LOGIC_GH
#define LIFETIME_LOGIC_GH

inductive lifetime_t = lifetime_ctor(int id); // Type of lifetimes
abstract_type thread_id_t; // Type of thread IDs

fixpoint lifetime_t lifetime_intersection(lifetime_t k, lifetime_t k1);
fixpoint bool lifetime_inclusion(lifetime_t k, lifetime_t k1);

lemma void lifetime_intersection_symm(lifetime_t k, lifetime_t k1);
    requires true;
    ensures lifetime_intersection(k, k1) == lifetime_intersection(k1, k);

lemma_auto(lifetime_intersection(k, k1)) void lifetime_inclusion_intersection(lifetime_t k, lifetime_t k1);
    requires true;
    ensures lifetime_inclusion(lifetime_intersection(k, k1), k) == true;

predicate lifetime_token(lifetime_t k;); // Lifetime token
predicate lifetime_dead_token(lifetime_t k;);

lemma void lifetime_token_inv(lifetime_t k);
    requires [?q]lifetime_token(k);
    ensures [q]lifetime_token(k) &*& 0 < q &*& q <= 1;

lemma lifetime_t begin_lifetime();
    requires true;
    ensures lifetime_token(result);

lemma void end_lifetime(lifetime_t k);
    requires lifetime_token(k);
    ensures [_]lifetime_dead_token(k);

lemma void close_lifetime_intersection_token(real q, lifetime_t k, lifetime_t k1);
    requires [q]lifetime_token(k) &*& [q]lifetime_token(k1);
    ensures [q]lifetime_token(lifetime_intersection(k, k1));

lemma void open_lifetime_intersection_token(real q, lifetime_t k, lifetime_t k1);
    requires [q]lifetime_token(lifetime_intersection(k, k1));
    ensures [q]lifetime_token(k) &*& [q]lifetime_token(k1);

lemma void close_lifetime_intersection_dead_token(lifetime_t k, lifetime_t k1);
    requires [_]lifetime_dead_token(k);
    ensures [_]lifetime_dead_token(lifetime_intersection(k, k1));

predicate thread_token(thread_id_t t); // Non-atomic token with Top mask ([NaInv: t.Top] in RustBelt)

// Full borrow
predicate full_borrow(lifetime_t k, predicate() P);

predicate close_full_borrow_token(predicate() P, real q, lifetime_t k); // accessor closing inheritance

lemma void open_full_borrow(real q, lifetime_t k, predicate() P);
    requires full_borrow(k, P) &*& [q]lifetime_token(k);
    ensures P() &*& close_full_borrow_token(P, q, k);

lemma void close_full_borrow(predicate() P);
    requires close_full_borrow_token(P, ?q, ?k) &*& P();
    ensures full_borrow(k, P) &*& [q]lifetime_token(k);

predicate end_reborrow_token(lifetime_t k1, lifetime_t k, predicate() P);

lemma void reborrow(lifetime_t k1, lifetime_t k, predicate() P);
    requires lifetime_inclusion(k1, k) == true &*& full_borrow(k, P);
    ensures full_borrow(k1, P) &*& end_reborrow_token(k1, k, P);

lemma void end_reborrow(lifetime_t k1, lifetime_t k, predicate() P);
    requires end_reborrow_token(k1, k, P) &*& [_]lifetime_dead_token(k1);
    ensures full_borrow(k, P);

typedef lemma void implies(predicate() P, predicate() P1)();
    requires P();
    ensures P1();

lemma void full_borrow_implies(lifetime_t k, predicate() P, predicate() P1);
    requires full_borrow(k, P) &*& is_implies(?f, P, P1) &*& is_implies(?f1, P1, P);
    ensures full_borrow(k, P1) &*& is_implies(f, P, P1) &*& is_implies(f1, P1, P);

// Non-atomic persistent borrow
predicate nonatomic_borrow(lifetime_t k, thread_id_t t, predicate() P);

lemma void full_borrow_into_nonatomic_borrow(lifetime_t k, thread_id_t t, predicate() P);
    requires full_borrow(k, P);
    ensures [_]nonatomic_borrow(k, t, P);

lemma void nonatomic_borrow_mono(lifetime_t k, lifetime_t k1, thread_id_t t, predicate() P);
    requires [_]nonatomic_borrow(k, t, P) &*& lifetime_inclusion(k1, k) == true;
    ensures [_]nonatomic_borrow(k1, t, P);

predicate close_nonatomic_borrow_token(predicate() P, real q, lifetime_t k, thread_id_t t);

// Rule LftL-Na-Acc with N = Nshr.l and requiring [NaInv:t.Top] instead of [NaInv:t.N]
lemma void open_nonatomic_borrow(lifetime_t k, thread_id_t t, real q);
    requires [_]nonatomic_borrow(k, t, ?P) &*& [q]lifetime_token(k) &*& thread_token(t);
    ensures P() &*& close_nonatomic_borrow_token(P, q, k, t);

lemma void close_nonatomic_borrow();
    requires close_nonatomic_borrow_token(?P, ?q, ?k, ?t) &*& P();
    ensures [q]lifetime_token(k) &*& thread_token(t);
#endif
