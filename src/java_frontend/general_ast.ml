(*

Copyright (C) 2013 Katholieke Universiteit Leuven
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*)

open Misc

(* open Num *)
open Big_int

(* 
  This file contains all the definitions for specifing a general 
  intermediate AST generated by the OCaml Ast_reader module after 
  reading in the serialized form generated by the Java AstVisitor
  in javac. To print out an AST use the Ast_writer module.
*)

(* ------------------------ *)
(* AST definitions          *)
(* ------------------------ *)

(* locations *)
type 
  source_location =
  | NoSource
  | SourceLine of string * int * int * int   
   (* [SourceLine (filename, line, startColumn, endColumn)] *)
  | SourceLines of string * int * int * int * int 
   (* [SourceLines (filename, startLine, startColumn, endLine, endColumn)] *)
and
  gen_source =
  | Original
  | Generated


(* verifier annotations *)
and
  annotation =
  | Annotation of
      source_location * 
      string           (* Annotation contents *)


(* names *)
and
  identifier =
  | Identifier of
      source_location *
      string (* Name of this identifier *)  
and
  name =
  | Name of
      source_location *
      identifier list (* Sequence of the dot-seperated identifiers of 
                         this fully qualified name *)


(* accessibility *)
and
  accessibility =
  | PublicAccess
  | PackageAccess
  | ProtectedAccess
  | PrivateAccess
and
  static_binding =
  | Static
  | NonStatic
and
  abstractness =
  | Abstract
  | NonAbstract
and
  finality =
  | Final
  | NonFinal


(* types *)
and
  prim_type =
  | VoidType of source_location
  | BoolType of source_location
  | CharType of source_location
  | ByteType of source_location
  | ShortType of source_location
  | IntType of source_location
  | LongType of source_location
  | FloatType of source_location
  | DoubleType of source_location
and
  ref_type =
  | SimpleRef of
      name                 (* Name of the referenced type *)
  | TypeApply of
      source_location *
      name *               (* Name of the refererenced parameterized type *)
      ref_type list        (* Type arguments for this type instantiation *)
  | WildCard of
      source_location *
      ref_type option *    (* Possible type bound of the wildcard *)
      wild_card_bound_kind (* Is the bound an upper or lower bound? *)
and
  wild_card_bound_kind =
  | Upper
  | Lower
  | Unbound
and
  type_ =
  | PrimType of
      prim_type (* The primitive type *)
  | RefType of                           
      ref_type  (* The referenced type *)
  | ArrayType of
      type_     (* Type of the elements in an array of this array type *)
and
  type_param =
  | TypeParam of
      source_location *
      identifier *  (* Identifier for this type parameter *)
      ref_type list (* List of bounds for this type parameter *)


(* package level *)
and 
  package =
  | Package of 
      source_location * 
      name *            (* Package name *)
      import list *     (* Import list *)
      package_decl list (* Package declaration list *)
and
  import =
  | Import of
      source_location *
      name *            (* Imported package name *)
      identifier option (* None means entire package, 
                           Some x means only x from specified package *)
and
  package_decl =
  | P_Annotation of 
      annotation           (* Annotation at package level *)
  | P_Class of
      interface_class_enum (* Interface/class/enum declaration at 
                              package level *)


(* class level *)
and
  interface_class_enum =
  | Class of
      source_location *
      annotation list * (* Annotation list (VeriFast style) *)
      identifier *      (* Identifier for this class *)
      type_param list * (* The type parameters of this class *)
      accessibility *   (* Is this class public, package or private? *)
      abstractness *    (* Is this class abstract? *)
      finality *        (* Is this class final? *)
      static_binding *  (* Is this class static? *)
      ref_type option * (* None means this class does not extend some other
                           Some x means this class extends x *)
      ref_type list *   (* List of interfaces that this class implements *)
      class_decl list   (* List of declarations from this class in order *)
  | Interface of
      source_location *
      annotation list * (* Interface annotation list (VeriFast style) *)
      identifier *      (* Identifier for this interface *)
      type_param list * (* The type parameters of this interface *)
      accessibility *   (* Is this interface public, package or private? *)
      ref_type list *   (* List of interfaces that this interface extends *)
      class_decl list   (* List of declarations from this interface in 
                           order *)
  | Enum of
      source_location *
      annotation list * (* Enum annotation list (VeriFast style) *)
      identifier *      (* Identifier for this enum *)
      accessibility *   (* Is this enum public, package or private? *)
      identifier list   (* List of enumerators for this enumeration *)
                    (* 
                    Currentlry only simple enumerations are supported, e.g:
                      public enum Foo
                      {
                        First,
                        Second;
                      }
                    No method (including constructors) or instance 
                    variable declarations are allowed inside an enum
                    *)
and
  class_decl =
  | C_Annotation of  
      annotation           (* Annotation at class level *)
  | C_Class of
      interface_class_enum (* Interface/class/enum declaration at class 
                              level (i.e. inner class) *)
  | StaticBlock of
      source_location *
      statement list      (* Statements in this static block *)
  | Field of
      source_location *
      identifier *        (* Identifier of this field *)
      accessibility *     (* Is this variable public, package, protected 
                             or private? *)
      finality *          (* Is this variable final? *)
      static_binding *    (* Is this variable static? *)
      type_ *             (* The type of this variable *)
      expression option * (* Possible initializing expression *)
      gen_source          (* Is this field auto generated? *)
  | Constructor of
      source_location *
      annotation list * (* Consructor annotation list (VeriFast style) *)
      type_param list * (* The type parameters of this constructor *)
      accessibility *   (* Is this constructor public, package, protected 
                           or private? *)
      variable_decl list *  (* The parameters for this constructor *)
      (ref_type * annotation option) list * 
                        (* List of possible thrown exceptions 
                           together with their annotations *)
      statement list option * (* Possible statements in body of constructor *)
      gen_source        (* Is this constructor auto generated? *)
  | Method of
      source_location *
      annotation list * (* Method annotation list (VeriFast style) *)
      identifier *      (* Identifier for this method *)
      type_param list * (* The type parameters of this method *)
      accessibility *   (* Is this method public, package, protected 
                           or private? *)
      abstractness *    (* Is this method abstract? *)
      finality *        (* Is this method final? *)
      static_binding *  (* Is this method static? *)
      type_ *           (* The return type of this method *)
      variable_decl list *           (* The parameters for this method *)
      (ref_type * annotation option) list * 
                        (* List of possible thrown exceptions 
                           together with their annotations *)
      statement list option * (* List of statements in possible body of function *)
      gen_source        (* Is this method auto generated? *)
and
  variable_decl =
  | Variable of
      source_location *
      identifier *      (* Identifier of this local variable *)
      type_ *           (* The type of this variable *)
      expression option (* Possible initializing expression *)


(* statements *)
and
  statement =
  | S_Annotation of
      annotation
  | S_Variable of
      variable_decl
  | S_Expression of
      expression
  | Block of
      source_location *
      statement list    (* List of statements in this block *)
  | Try of
      source_location *
      statement list *  (* Body of this try block *)
      catch list        (* List of catch blocks associated with this 
                           try block *)
  | DoWhile of
      source_location *
      annotation list * (* Loop annotation list (VeriFast style) *)
      expression *      (* Loop condition of this loop as an expression *)
      statement list    (* Body of this loop *)
  | While of
      source_location *
      annotation list * (* Loop annotation list (VeriFast style) *)
      expression *      (* Loop condition of this loop as an expression *)
      statement list    (* Body of this loop *)
  | For of
      source_location *
      annotation list * (* Loop annotation list (VeriFast style) *)
      statement list *  (* Initializing statements of this for loop 
                           (i.e. for( * ; ; )) *)
      expression *      (* Loop condition of loop as an expression  
                           (i.e. for( ; * ; )) *)
      statement list *  (* Updating statements of this for loop     
                           (i.e. for( ; ; * )) *)
      statement list    (* Body of this loop *)
  | Foreach of
      source_location *
      annotation list * (* Loop annotation list (VeriFast style) *)
      variable_decl *   (* Variable declaration for the loop variable *)
      expression *      (* Container to loop over as an expression *)
      statement list    (* Body of this loop *)
  | Labeled of
      source_location *
      identifier *      (* The name of the label of this labeled statement *)  
      statement         (* Body of this labeled statement *)
  | Switch of
      source_location *
      expression *      (* Selector of this switch statement *)  
      case list *       (* List of cases in this switch statement *)
      case option       (* Possible default case of this switch statement *)
  | If of
      source_location *
      expression *      (* Branching condition for this if statment *)
      statement list *  (* If branch of this if statment *)
      statement list    (* Else branch of this if statment *)
  | Break of 
      source_location
  | Continue of 
      source_location
  | Return of
      source_location *
      expression option (* Possible expression that is returned by this 
                           return statement *)
  | Throw of
      source_location *
      expression (* Expression (which should be Throwable) that is thrown 
                    by this throw statement *)
  | Assert of
      source_location *
      expression *       (* Failing condition for this assert *)
      expression option  (* Detailed information (implicit String conversion  
                            when evaluated) associated with this assert *) 
and
  case =
  | Case of 
      source_location *
      expression option * (* Pattern matched by this case from a switch 
                             statment *)
      statement list      (* List of statements in this case from a switch 
                            statment *)
and
  catch =
  | Catch of 
      source_location *
      variable_decl * (* Declaration of Throwable object that is catched by 
                         this catch block *)
      statement list  (* Body of this catch block *)


(* expressions *)
and
  expression =
  | E_Identifier of
      identifier
  | Access of
      source_location *
      expression *      (* Object that is inspected *)
      identifier        (* Name of selected member *)
  | Apply of
      source_location *
      type_param list * (* List of type parameters for this method 
                           invocation *)
      expression *      (* Method that is called *)
      expression list   (* List of arguments provided for this method 
                           invocation *)
  | NewClass of
      source_location *
      type_param list * (* List of type parameters for this constructor 
                           invocation *)
      ref_type *        (* Type of the class that is instantiated *)
      expression list   (* List of arguments provided for this constructor 
                           invocation *)
  | NewArray of
      source_location *
      type_ *           (* Type of elements in the newly created array *)
      expression list * (* List of dimentions as expressions *)
      expression list   (* List of expressions to initialize the newly 
                           created array *)
  | Assign of
      source_location *                      
      bin_operator option * (* Possible binary operator for this assigment: 
                                e.g. 'None' means just '=' (no operator), 
                                     'some O_Plus' means '+=' *)
      expression *          (* Left hand side of this assignment *)
      expression            (* Right hand side of this assignment *)
  | Unary of
      source_location *                      
      uni_operator * (* Operator in this unary expression *)
      expression     (* Only argument to this unary operator *)
  | Binary of
      source_location *                      
      bin_operator * (* Operator in this binary expression  *)
      expression *   (* Left hand side argument to this binary operator *)
      expression     (* Right hand side argument to this binary operator *)
  | Ternary of
      source_location *
      expression * (* Branching condition for this ternary operator *)
      expression * (* True branch of this ternary operator *)
      expression   (* False branch of this ternary operator *)
  | TypeCast of
      source_location *
      type_ *    (* Type to cast the given expression to *)
      expression (* Expression which is cast do the speciefied type *) 
  | TypeTest of
      source_location *
      type_ *    (* Type to check the given expression's type against *)
      expression (* Expression which is tested for its type *)
  | ArrayAccess of
      source_location *
      expression * (* Array that is indexed *)
      expression   (* Index of array access *)
  | Literal of
      source_location *                            
      type_ * (* Type of this literal:
                  -If type_ is a prim_type then the meaning is clear
                  -If type_ is a reftype ten it must be a String literal,
                   otherwise it is considered as the "null" literal *)
      string  (* Value of this literal as a string *)


and 
  bin_operator =
  | O_Plus    (* "+" *)
  | O_Min     (* "-" *)
  | O_Mul     (* "*" *)
  | O_Div     (* "/" *)
  | O_Mod     (* "%" *)
  | O_Or      (* "||" *)
  | O_And     (* "&&" *)
  | O_Eq      (* "==" *)
  | O_NotEq   (* "!=" *)
  | O_Lt      (* "<" *)
  | O_Gt      (* ">" *)
  | O_LtEq    (* "<=" *)
  | O_GtEq    (* ">=" *)
  | O_BitOr   (* "|" *)
  | O_BitXor  (* "^" *)
  | O_BitAnd  (* "&" *)
  | O_ShiftL  (* "<<" *)
  | O_ShiftR  (* ">>" *)
  | O_UShiftR (* ">>>" *)
and
  uni_operator=
  | O_Pos     (* "+" *)
  | O_Neg     (* "-" *)
  | O_Not     (* "!" *)
  | O_Compl   (* "~" *)
  | O_PreInc  (* "++var" *)
  | O_PreDec  (* "--var" *) 
  | O_PostInc (* "var++" *)
  | O_PostDec (* "var--" *)

(* -------------------------- *)
(* AST construction functions *)
(* -------------------------- *)

(* dummies *)
let dummy_loc = NoSource
let dummy_ident = Identifier(dummy_loc, "")
let dummy_name = Name(dummy_loc, [])
let dummy_package = Package(dummy_loc, Name(dummy_loc, []), [], [])

(* x_of_string *)
let name_of_string l name=
  let parts = List.map (fun x -> Identifier(l, x)) (split_string '.' name) in
  Name(l, parts)
let prim_type_of_string l t =
  if (t = "void") then VoidType(l)
  else if (t = "boolean") then BoolType(l)
  else if (t = "char") then CharType(l)
  else if (t = "byte") then ByteType(l)
  else if (t = "short") then ShortType(l)
  else if (t = "int") then IntType(l)
  else if (t = "long") then LongType(l)
  else if (t = "float") then FloatType(l)
  else if (t = "double") then DoubleType(l)
  else assert(false)    
let u_operator_of_string o =
       if (o = "+") then O_Pos
  else if (o = "-") then O_Neg
  else if (o = "!") then O_Not
  else if (o = "~") then O_Compl
  else if (o = "++x") then O_PreInc
  else if (o = "--x") then O_PreDec
  else if (o = "x++") then O_PostInc
  else if (o = "x--") then O_PreDec
  else assert(false)    
let b_operator_of_string o =
       if (o = "+") then O_Plus
  else if (o = "-") then O_Min
  else if (o = "*") then O_Mul
  else if (o = "/") then O_Div
  else if (o = "%") then O_Mod
  else if (o = "||") then O_Or
  else if (o = "&&") then O_And
  else if (o = "==") then O_Eq
  else if (o = "!=") then O_NotEq
  else if (o = "<") then O_Lt
  else if (o = ">") then O_Gt
  else if (o = "<=") then O_LtEq
  else if (o = ">=") then O_GtEq
  else if (o = "|") then O_BitOr
  else if (o = "^") then O_BitXor
  else if (o = "&") then O_BitAnd
  else if (o = "<<") then O_ShiftL
  else if (o = ">>") then O_ShiftR
  else if (o = ">>>") then O_UShiftR 
  else assert(false)
let a_operator_of_string o =
       if (o = "|=") then O_BitOr
  else if (o = "^=") then O_BitXor
  else if (o = "&=") then O_BitAnd
  else if (o = "<<=") then O_ShiftL
  else if (o = ">>=") then O_ShiftR
  else if (o = ">>>=") then O_UShiftR
  else if (o = "+=") then O_Plus
  else if (o = "-=") then O_Min
  else if (o = "*=") then O_Mul
  else if (o = "/=") then O_Div
  else if (o = "%=") then O_Mod
  else assert(false)

(* -------------------------- *)
(* AST inspection functions   *)
(* -------------------------- *)

(* string_of_x *)
(* let string_of_srcpos (p,l,c) = p ^ "(" ^ string_of_int l ^ "," ^ string_of_int c ^ ")" *)
let string_of_path (basedir, relpath) = concat basedir relpath
let string_of_loc loc =
  let (f, l1, c1, l2, c2) = 
    match loc with 
      NoSource -> ("<nowhere>", 0, 0, 0, 0)
    | SourceLine(f, l, c1 ,c2) -> (f, l, c1, l,c2)
    | SourceLines(f, l1, c1, l2 ,c2) -> (f, l1, c1, l2 ,c2)
  in
  "(" ^ f ^ ", " ^ (string_of_int l1) ^ ", " ^ (string_of_int c1) ^ ", " ^ 
                   (string_of_int l2) ^ ", " ^ (string_of_int c2) ^ ")"
let string_of_identifier id =
  match id with Identifier(_, name) -> name
let string_of_name name =
  match name with Name(_, parts) -> String.concat "." (List.map string_of_identifier parts)
let string_of_annotation ann =
  match ann with Annotation(_, a) -> a
let string_of_prim_type t =
  match t with
  | VoidType _ -> "void"
  | BoolType _ -> "boolean"
  | CharType _ -> "char"
  | ByteType _ -> "byte"
  | ShortType _ -> "short"
  | IntType _ -> "int"
  | LongType _ -> "long"
  | FloatType _ -> "float"
  | DoubleType _ -> "double"
let rec string_of_ref_type t =
  match t with
  | SimpleRef n -> string_of_name n
  | TypeApply(l, n, args) ->
      (string_of_name n) ^ 
      (if List.length args > 0 then
        "<" ^ (String.concat ", " (List.map string_of_ref_type args)) ^ ">"
       else
        "" )
  | WildCard(l, typ, kind) ->
      match typ with
        Some(typ) ->
          "? " ^ (if kind = Upper then "extends " else "super ") ^ (string_of_ref_type typ)
      | None -> "?"
and string_of_type t =
  match t with
  | PrimType t -> string_of_prim_type t
  | RefType t -> string_of_ref_type t
  | ArrayType t -> string_of_type t
let string_of_accessibility access =
  match access with
  | PublicAccess -> "public"
  | PackageAccess -> "package"
  | ProtectedAccess -> "protected"
  | PrivateAccess -> "private"

(* string_equals_x *)
let string_equals_identifier s n =
  s = string_of_identifier n 
let string_equals_name s n =
  s = string_of_name n

(* misc *)
let extend_location loc1 loc2 =
  let extend_location(f, l0, c0) =
    match loc1 with 
    | SourceLine(f, l, c1 ,c2) when l <= l0 ->
        if (l == l0 && c2 <= c0) then
          SourceLine(f, l, c1, c0)
        else if (l < l0) then
          SourceLines(f, l, l0, c1, c0)
        else 
          loc1
    | SourceLines(f, l1, c1, l2 ,c2) when l2 <= l0 && (l2 = l0 || c2 <= c0)->
        SourceLines(f, l1, c1, l0 ,c0)
    | _ -> loc1
  in
  match loc2 with 
    NoSource -> loc1
  | SourceLine(f, l, c1 ,c2) -> extend_location(f, l, c1)
  | SourceLines(f, l1, c1, l2 ,c2) -> extend_location(f, l1, c1)

let remove_last_id name=
  match name with
    Name(loc, parts) ->
      if List.length parts > 0 then
        let id = get_last parts in
        let loc_id = match id with Identifier(l, _) -> l in
        let loc' = extend_location loc loc_id in  
        (Name(loc', remove_last parts), id)
      else
        (name, Identifier(dummy_loc, ""))


(* -------------------------- *)
(* End                        *)
(* -------------------------- *)

